diff --git a/setools/__init__.py b/setools/__init__.py
index a84c846..b977b92 100644
--- a/setools/__init__.py
+++ b/setools/__init__.py
@@ -74,11 +74,11 @@ from .pcideviceconquery import PcideviceconQuery
 from .devicetreeconquery import DevicetreeconQuery
 
 # Information Flow Analysis
-from .infoflow import InfoFlowAnalysis
-from .permmap import PermissionMap
+#from .infoflow import InfoFlowAnalysis
+#from .permmap import PermissionMap
 
 # Domain Transition Analysis
-from .dta import DomainTransitionAnalysis
+#from .dta import DomainTransitionAnalysis
 
 # Policy difference
 from .diff import PolicyDifference
diff --git a/setools/dta.py b/setools/dta.py
deleted file mode 100644
index 63317d1..0000000
--- a/setools/dta.py
+++ /dev/null
@@ -1,624 +0,0 @@
-# Copyright 2014-2015, Tresys Technology, LLC
-#
-# This file is part of SETools.
-#
-# SETools is free software: you can redistribute it and/or modify
-# it under the terms of the GNU Lesser General Public License as
-# published by the Free Software Foundation, either version 2.1 of
-# the License, or (at your option) any later version.
-#
-# SETools is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU Lesser General Public License for more details.
-#
-# You should have received a copy of the GNU Lesser General Public
-# License along with SETools.  If not, see
-# <http://www.gnu.org/licenses/>.
-#
-# pylint: disable=unsubscriptable-object
-
-import itertools
-import logging
-from collections import defaultdict, namedtuple
-
-import networkx as nx
-from networkx.exception import NetworkXError, NetworkXNoPath
-
-from .descriptors import EdgeAttrDict, EdgeAttrList
-from .policyrep import TERuletype
-
-__all__ = ['DomainTransitionAnalysis']
-
-# Return values for the analysis
-# are in the following tuple formats:
-step_output = namedtuple("step", ["source",
-                                  "target",
-                                  "transition",
-                                  "entrypoints",
-                                  "setexec",
-                                  "dyntransition",
-                                  "setcurrent"])
-
-entrypoint_output = namedtuple("entrypoints", ["name",
-                                               "entrypoint",
-                                               "execute",
-                                               "type_transition"])
-
-
-class DomainTransitionAnalysis(object):
-
-    """Domain transition analysis."""
-
-    def __init__(self, policy, reverse=False, exclude=None):
-        """
-        Parameter:
-        policy   The policy to analyze.
-        """
-        self.log = logging.getLogger(__name__)
-
-        self.policy = policy
-        self.exclude = exclude
-        self.reverse = reverse
-        self.rebuildgraph = True
-        self.rebuildsubgraph = True
-        self.G = nx.DiGraph()
-        self.subG = None
-
-    @property
-    def reverse(self):
-        return self._reverse
-
-    @reverse.setter
-    def reverse(self, direction):
-        self._reverse = bool(direction)
-        self.rebuildsubgraph = True
-
-    @property
-    def exclude(self):
-        return self._exclude
-
-    @exclude.setter
-    def exclude(self, types):
-        if types:
-            self._exclude = [self.policy.lookup_type(t) for t in types]
-        else:
-            self._exclude = []
-
-        self.rebuildsubgraph = True
-
-    def shortest_path(self, source, target):
-        """
-        Generator which yields one shortest domain transition path
-        between the source and target types (there may be more).
-
-        Parameters:
-        source  The source type.
-        target  The target type.
-
-        Yield: generator(steps)
-
-        steps   A generator that returns the tuple of
-                source, target, and rules for each
-                domain transition.
-        """
-        s = self.policy.lookup_type(source)
-        t = self.policy.lookup_type(target)
-
-        if self.rebuildsubgraph:
-            self._build_subgraph()
-
-        self.log.info("Generating one domain transition path from {0} to {1}...".format(s, t))
-
-        try:
-            yield self.__generate_steps(nx.shortest_path(self.subG, s, t))
-        except (NetworkXNoPath, NetworkXError):
-            # NetworkXError: the type is valid but not in graph, e.g. excluded
-            # NetworkXNoPath: no paths or the target type is
-            # not in the graph
-            pass
-
-    def all_paths(self, source, target, maxlen=2):
-        """
-        Generator which yields all domain transition paths between
-        the source and target up to the specified maximum path
-        length.
-
-        Parameters:
-        source   The source type.
-        target   The target type.
-        maxlen   Maximum length of paths.
-
-        Yield: generator(steps)
-
-        steps    A generator that returns the tuple of
-                 source, target, and rules for each
-                 domain transition.
-        """
-        if maxlen < 1:
-            raise ValueError("Maximum path length must be positive.")
-
-        s = self.policy.lookup_type(source)
-        t = self.policy.lookup_type(target)
-
-        if self.rebuildsubgraph:
-            self._build_subgraph()
-
-        self.log.info("Generating all domain transition paths from {0} to {1}, max length {2}...".
-                      format(s, t, maxlen))
-
-        try:
-            for path in nx.all_simple_paths(self.subG, s, t, maxlen):
-                yield self.__generate_steps(path)
-        except (NetworkXNoPath, NetworkXError):
-            # NetworkXError: the type is valid but not in graph, e.g. excluded
-            # NetworkXNoPath: no paths or the target type is
-            # not in the graph
-            pass
-
-    def all_shortest_paths(self, source, target):
-        """
-        Generator which yields all shortest domain transition paths
-        between the source and target types.
-
-        Parameters:
-        source   The source type.
-        target   The target type.
-
-        Yield: generator(steps)
-
-        steps    A generator that returns the tuple of
-                 source, target, and rules for each
-                 domain transition.
-        """
-        s = self.policy.lookup_type(source)
-        t = self.policy.lookup_type(target)
-
-        if self.rebuildsubgraph:
-            self._build_subgraph()
-
-        self.log.info("Generating all shortest domain transition paths from {0} to {1}...".
-                      format(s, t))
-
-        try:
-            for path in nx.all_shortest_paths(self.subG, s, t):
-                yield self.__generate_steps(path)
-        except (NetworkXNoPath, NetworkXError, KeyError):
-            # NetworkXError: the type is valid but not in graph, e.g. excluded
-            # NetworkXNoPath: no paths or the target type is
-            # not in the graph
-            # KeyError: work around NetworkX bug
-            # when the source node is not in the graph
-            pass
-
-    def transitions(self, type_):
-        """
-        Generator which yields all domain transitions out of a
-        specified source type.
-
-        Parameters:
-        type_   The starting type.
-
-        Yield: generator(steps)
-
-        steps   A generator that returns the tuple of
-                source, target, and rules for each
-                domain transition.
-        """
-        s = self.policy.lookup_type(type_)
-
-        if self.rebuildsubgraph:
-            self._build_subgraph()
-
-        self.log.info("Generating all domain transitions {1} {0}".
-                      format(s, "in to" if self.reverse else "out from"))
-
-        try:
-            for source, target in self.subG.out_edges_iter(s):
-                edge = Edge(self.subG, source, target)
-
-                if self.reverse:
-                    real_source, real_target = target, source
-                else:
-                    real_source, real_target = source, target
-
-                yield step_output(real_source, real_target,
-                                  edge.transition,
-                                  self.__generate_entrypoints(edge),
-                                  edge.setexec,
-                                  edge.dyntransition,
-                                  edge.setcurrent)
-
-        except NetworkXError:
-            # NetworkXError: the type is valid but not in graph, e.g. excluded
-            pass
-
-    def get_stats(self):  # pragma: no cover
-        """
-        Get the domain transition graph statistics.
-
-        Return: str
-        """
-        if self.rebuildgraph:
-            self._build_graph()
-
-        return nx.info(self.G)
-
-    #
-    # Internal functions follow
-    #
-    @staticmethod
-    def __generate_entrypoints(edge):
-        """
-        Creates a list of entrypoint, execute, and
-        type_transition rules for each entrypoint.
-
-        Parameter:
-        data     The dictionary of entrypoints.
-
-        Return: list of tuple(type, entry, exec, trans)
-
-        type     The entrypoint type.
-        entry    The list of entrypoint rules.
-        exec     The list of execute rules.
-        trans    The list of type_transition rules.
-        """
-        return [entrypoint_output(e, edge.entrypoint[e], edge.execute[e], edge.type_transition[e])
-                for e in edge.entrypoint]
-
-    def __generate_steps(self, path):
-        """
-        Generator which yields the source, target, and associated rules
-        for each domain transition.
-
-        Parameter:
-        path     A list of graph node names representing an information flow path.
-
-        Yield: tuple(source, target, transition, entrypoints,
-                     setexec, dyntransition, setcurrent)
-
-        source          The source type for this step of the domain transition.
-        target          The target type for this step of the domain transition.
-        transition      The list of transition rules.
-        entrypoints     Generator which yields entrypoint-related rules.
-        setexec         The list of setexec rules.
-        dyntranstion    The list of dynamic transition rules.
-        setcurrent      The list of setcurrent rules.
-        """
-
-        for s in range(1, len(path)):
-            source = path[s - 1]
-            target = path[s]
-            edge = Edge(self.subG, source, target)
-
-            # Yield the actual source and target.
-            # The above perspective is reversed
-            # if the graph has been reversed.
-            if self.reverse:
-                real_source, real_target = target, source
-            else:
-                real_source, real_target = source, target
-
-            yield step_output(real_source, real_target,
-                              edge.transition,
-                              self.__generate_entrypoints(edge),
-                              edge.setexec,
-                              edge.dyntransition,
-                              edge.setcurrent)
-
-    #
-    # Graph building functions
-    #
-
-    # Domain transition requirements:
-    #
-    # Standard transitions a->b:
-    # allow a b:process transition;
-    # allow a b_exec:file execute;
-    # allow b b_exec:file entrypoint;
-    #
-    # and at least one of:
-    # allow a self:process setexec;
-    # type_transition a b_exec:process b;
-    #
-    # Dynamic transition x->y:
-    # allow x y:process dyntransition;
-    # allow x self:process setcurrent;
-    #
-    # Algorithm summary:
-    # 1. iterate over all rules
-    #   1. skip non allow/type_transition rules
-    #   2. if process transition or dyntransition, create edge,
-    #      initialize rule lists, add the (dyn)transition rule
-    #   3. if process setexec or setcurrent, add to appropriate dict
-    #      keyed on the subject
-    #   4. if file exec, entrypoint, or type_transition:process,
-    #      add to appropriate dict keyed on subject,object.
-    # 2. Iterate over all graph edges:
-    #   1. if there is a transition rule (else add to invalid
-    #      transition list):
-    #       1. use set intersection to find matching exec
-    #          and entrypoint rules. If none, add to invalid
-    #          transition list.
-    #       2. for each valid entrypoint, add rules to the
-    #          edge's lists if there is either a
-    #          type_transition for it or the source process
-    #          has setexec permissions.
-    #       3. If there are neither type_transitions nor
-    #          setexec permissions, add to the invalid
-    #          transition list
-    #   2. if there is a dyntransition rule (else add to invalid
-    #      dyntrans list):
-    #       1. If the source has a setcurrent rule, add it
-    #          to the edge's list, else add to invalid
-    #          dyntransition list.
-    # 3. Iterate over all graph edges:
-    #   1. if the edge has an invalid trans and dyntrans, delete
-    #      the edge.
-    #   2. if the edge has an invalid trans, clear the related
-    #      lists on the edge.
-    #   3. if the edge has an invalid dyntrans, clear the related
-    #      lists on the edge.
-    #
-    def _build_graph(self):
-        self.G.clear()
-        self.G.name = "Domain transition graph for {0}.".format(self.policy)
-
-        self.log.info("Building domain transition graph from {0}...".format(self.policy))
-
-        # hash tables keyed on domain type
-        setexec = defaultdict(list)
-        setcurrent = defaultdict(list)
-
-        # hash tables keyed on (domain, entrypoint file type)
-        # the parameter for defaultdict has to be callable
-        # hence the lambda for the nested defaultdict
-        execute = defaultdict(lambda: defaultdict(list))
-        entrypoint = defaultdict(lambda: defaultdict(list))
-
-        # hash table keyed on (domain, entrypoint, target domain)
-        type_trans = defaultdict(lambda: defaultdict(lambda: defaultdict(list)))
-
-        for rule in self.policy.terules():
-            if rule.ruletype == TERuletype.allow:
-                if rule.tclass not in ["process", "file"]:
-                    continue
-
-                perms = rule.perms
-
-                if rule.tclass == "process":
-                    if "transition" in perms:
-                        for s, t in itertools.product(rule.source.expand(), rule.target.expand()):
-                            # only add edges if they actually
-                            # transition to a new type
-                            if s != t:
-                                edge = Edge(self.G, s, t, create=True)
-                                edge.transition.append(rule)
-
-                    if "dyntransition" in perms:
-                        for s, t in itertools.product(rule.source.expand(), rule.target.expand()):
-                            # only add edges if they actually
-                            # transition to a new type
-                            if s != t:
-                                e = Edge(self.G, s, t, create=True)
-                                e.dyntransition.append(rule)
-
-                    if "setexec" in perms:
-                        for s in rule.source.expand():
-                            setexec[s].append(rule)
-
-                    if "setcurrent" in perms:
-                        for s in rule.source.expand():
-                            setcurrent[s].append(rule)
-
-                else:
-                    if "execute" in perms:
-                        for s, t in itertools.product(
-                                rule.source.expand(),
-                                rule.target.expand()):
-                            execute[s][t].append(rule)
-
-                    if "entrypoint" in perms:
-                        for s, t in itertools.product(rule.source.expand(), rule.target.expand()):
-                            entrypoint[s][t].append(rule)
-
-            elif rule.ruletype == TERuletype.type_transition:
-                if rule.tclass != "process":
-                    continue
-
-                d = rule.default
-                for s, t in itertools.product(rule.source.expand(), rule.target.expand()):
-                    type_trans[s][t][d].append(rule)
-
-        invalid_edge = []
-        clear_transition = []
-        clear_dyntransition = []
-
-        for s, t in self.G.edges_iter():
-            edge = Edge(self.G, s, t)
-            invalid_trans = False
-            invalid_dyntrans = False
-
-            if edge.transition:
-                # get matching domain exec w/entrypoint type
-                entry = set(entrypoint[t].keys())
-                exe = set(execute[s].keys())
-                match = entry.intersection(exe)
-
-                if not match:
-                    # there are no valid entrypoints
-                    invalid_trans = True
-                else:
-                    # TODO try to improve the
-                    # efficiency in this loop
-                    for m in match:
-                        if s in setexec or type_trans[s][m]:
-                            # add key for each entrypoint
-                            edge.entrypoint[m] += entrypoint[t][m]
-                            edge.execute[m] += execute[s][m]
-
-                        if type_trans[s][m][t]:
-                            edge.type_transition[m] += type_trans[s][m][t]
-
-                    if s in setexec:
-                        edge.setexec.extend(setexec[s])
-
-                    if not edge.setexec and not edge.type_transition:
-                        invalid_trans = True
-            else:
-                invalid_trans = True
-
-            if edge.dyntransition:
-                if s in setcurrent:
-                    edge.setcurrent.extend(setcurrent[s])
-                else:
-                    invalid_dyntrans = True
-            else:
-                invalid_dyntrans = True
-
-            # cannot change the edges while iterating over them,
-            # so keep appropriate lists
-            if invalid_trans and invalid_dyntrans:
-                invalid_edge.append(edge)
-            elif invalid_trans:
-                clear_transition.append(edge)
-            elif invalid_dyntrans:
-                clear_dyntransition.append(edge)
-
-        # Remove invalid transitions
-        self.G.remove_edges_from(invalid_edge)
-        for edge in clear_transition:
-            # if only the regular transition is invalid,
-            # clear the relevant lists
-            del edge.transition
-            del edge.execute
-            del edge.entrypoint
-            del edge.type_transition
-            del edge.setexec
-        for edge in clear_dyntransition:
-            # if only the dynamic transition is invalid,
-            # clear the relevant lists
-            del edge.dyntransition
-            del edge.setcurrent
-
-        self.rebuildgraph = False
-        self.rebuildsubgraph = True
-        self.log.info("Completed building domain transition graph.")
-        self.log.debug("Graph stats: nodes: {0}, edges: {1}.".format(
-            nx.number_of_nodes(self.G),
-            nx.number_of_edges(self.G)))
-
-    def __remove_excluded_entrypoints(self):
-        invalid_edges = []
-        for source, target in self.subG.edges_iter():
-            edge = Edge(self.subG, source, target)
-            entrypoints = set(edge.entrypoint)
-            entrypoints.intersection_update(self.exclude)
-
-            if not entrypoints:
-                # short circuit if there are no
-                # excluded entrypoint types on
-                # this edge.
-                continue
-
-            for e in entrypoints:
-                # clear the entrypoint data
-                del edge.entrypoint[e]
-                del edge.execute[e]
-
-                try:
-                    del edge.type_transition[e]
-                except KeyError:  # setexec
-                    pass
-
-            # cannot delete the edges while iterating over them
-            if not edge.entrypoint and not edge.dyntransition:
-                invalid_edges.append(edge)
-
-        self.subG.remove_edges_from(invalid_edges)
-
-    def _build_subgraph(self):
-        if self.rebuildgraph:
-            self._build_graph()
-
-        self.log.info("Building domain transition subgraph.")
-        self.log.debug("Excluding {0}".format(self.exclude))
-        self.log.debug("Reverse {0}".format(self.reverse))
-
-        # reverse graph for reverse DTA
-        if self.reverse:
-            self.subG = self.G.reverse(copy=True)
-        else:
-            self.subG = self.G.copy()
-
-        if self.exclude:
-            # delete excluded domains from subgraph
-            self.subG.remove_nodes_from(self.exclude)
-
-            # delete excluded entrypoints from subgraph
-            self.__remove_excluded_entrypoints()
-
-        self.rebuildsubgraph = False
-        self.log.info("Completed building domain transition subgraph.")
-        self.log.debug("Subgraph stats: nodes: {0}, edges: {1}.".format(
-            nx.number_of_nodes(self.subG),
-            nx.number_of_edges(self.subG)))
-
-
-class Edge(object):
-
-    """
-    A graph edge.  Also used for returning domain transition steps.
-
-    Parameters:
-    graph       The NetworkX graph.
-    source      The source type of the edge.
-    target      The target tyep of the edge.
-
-    Keyword Parameters:
-    create      (T/F) create the edge if it does not exist.
-                The default is False.
-    """
-
-    transition = EdgeAttrList('transition')
-    setexec = EdgeAttrList('setexec')
-    dyntransition = EdgeAttrList('dyntransition')
-    setcurrent = EdgeAttrList('setcurrent')
-    entrypoint = EdgeAttrDict('entrypoint')
-    execute = EdgeAttrDict('execute')
-    type_transition = EdgeAttrDict('type_transition')
-
-    def __init__(self, graph, source, target, create=False):
-        self.G = graph
-        self.source = source
-        self.target = target
-
-        if not self.G.has_edge(source, target):
-            if not create:
-                raise ValueError("Edge does not exist in graph")
-            else:
-                self.G.add_edge(source, target)
-                self.transition = None
-                self.entrypoint = None
-                self.execute = None
-                self.type_transition = None
-                self.setexec = None
-                self.dyntransition = None
-                self.setcurrent = None
-
-    def __getitem__(self, key):
-        # This is implemented so this object can be used in NetworkX
-        # functions that operate on (source, target) tuples
-        if isinstance(key, slice):
-            return [self._index_to_item(i) for i in range(* key.indices(2))]
-        else:
-            return self._index_to_item(key)
-
-    def _index_to_item(self, index):
-        """Return source or target based on index."""
-        if index == 0:
-            return self.source
-        elif index == 1:
-            return self.target
-        else:
-            raise IndexError("Invalid index (edges only have 2 items): {0}".format(index))
diff --git a/setools/infoflow.py b/setools/infoflow.py
deleted file mode 100644
index 59d9591..0000000
--- a/setools/infoflow.py
+++ /dev/null
@@ -1,414 +0,0 @@
-# Copyright 2014-2015, Tresys Technology, LLC
-#
-# This file is part of SETools.
-#
-# SETools is free software: you can redistribute it and/or modify
-# it under the terms of the GNU Lesser General Public License as
-# published by the Free Software Foundation, either version 2.1 of
-# the License, or (at your option) any later version.
-#
-# SETools is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU Lesser General Public License for more details.
-#
-# You should have received a copy of the GNU Lesser General Public
-# License along with SETools.  If not, see
-# <http://www.gnu.org/licenses/>.
-#
-import itertools
-import logging
-
-import networkx as nx
-from networkx.exception import NetworkXError, NetworkXNoPath
-
-from .descriptors import EdgeAttrIntMax, EdgeAttrList
-from .policyrep import TERuletype
-
-__all__ = ['InfoFlowAnalysis']
-
-
-class InfoFlowAnalysis(object):
-
-    """Information flow analysis."""
-
-    def __init__(self, policy, perm_map, min_weight=1, exclude=None):
-        """
-        Parameters:
-        policy      The policy to analyze.
-        perm_map    The permission map or path to the permission map file.
-        minweight   The minimum permission weight to include in the analysis.
-                    (default is 1)
-        exclude     The types excluded from the information flow analysis.
-                    (default is none)
-        """
-        self.log = logging.getLogger(__name__)
-
-        self.policy = policy
-
-        self.min_weight = min_weight
-        self.perm_map = perm_map
-        self.exclude = exclude
-        self.rebuildgraph = True
-        self.rebuildsubgraph = True
-
-        self.G = nx.DiGraph()
-        self.subG = None
-
-    @property
-    def min_weight(self):
-        return self._min_weight
-
-    @min_weight.setter
-    def min_weight(self, weight):
-        if not 1 <= weight <= 10:
-            raise ValueError(
-                "Min information flow weight must be an integer 1-10.")
-
-        self._min_weight = weight
-        self.rebuildsubgraph = True
-
-    @property
-    def perm_map(self):
-        return self._perm_map
-
-    @perm_map.setter
-    def perm_map(self, perm_map):
-        self._perm_map = perm_map
-        self.rebuildgraph = True
-        self.rebuildsubgraph = True
-
-    @property
-    def exclude(self):
-        return self._exclude
-
-    @exclude.setter
-    def exclude(self, types):
-        if types:
-            self._exclude = [self.policy.lookup_type(t) for t in types]
-        else:
-            self._exclude = []
-
-        self.rebuildsubgraph = True
-
-    def shortest_path(self, source, target):
-        """
-        Generator which yields one shortest path between the source
-        and target types (there may be more).
-
-        Parameters:
-        source   The source type.
-        target   The target type.
-
-        Yield: generator(steps)
-
-        steps Yield: tuple(source, target, rules)
-
-        source   The source type for this step of the information flow.
-        target   The target type for this step of the information flow.
-        rules    The list of rules creating this information flow step.
-        """
-        s = self.policy.lookup_type(source)
-        t = self.policy.lookup_type(target)
-
-        if self.rebuildsubgraph:
-            self._build_subgraph()
-
-        self.log.info("Generating one shortest information flow path from {0} to {1}...".
-                      format(s, t))
-
-        try:
-            yield self.__generate_steps(nx.shortest_path(self.subG, s, t))
-        except (NetworkXNoPath, NetworkXError):
-            # NetworkXError: the type is valid but not in graph, e.g.
-            # excluded or disconnected due to min weight
-            # NetworkXNoPath: no paths or the target type is
-            # not in the graph
-            pass
-
-    def all_paths(self, source, target, maxlen=2):
-        """
-        Generator which yields all paths between the source and target
-        up to the specified maximum path length.  This algorithm
-        tends to get very expensive above 3-5 steps, depending
-        on the policy complexity.
-
-        Parameters:
-        source    The source type.
-        target    The target type.
-        maxlen    Maximum length of paths.
-
-        Yield: generator(steps)
-
-        steps Yield: tuple(source, target, rules)
-
-        source    The source type for this step of the information flow.
-        target    The target type for this step of the information flow.
-        rules     The list of rules creating this information flow step.
-        """
-        if maxlen < 1:
-            raise ValueError("Maximum path length must be positive.")
-
-        s = self.policy.lookup_type(source)
-        t = self.policy.lookup_type(target)
-
-        if self.rebuildsubgraph:
-            self._build_subgraph()
-
-        self.log.info("Generating all information flow paths from {0} to {1}, max length {2}...".
-                      format(s, t, maxlen))
-
-        try:
-            for path in nx.all_simple_paths(self.subG, s, t, maxlen):
-                yield self.__generate_steps(path)
-        except (NetworkXNoPath, NetworkXError):
-            # NetworkXError: the type is valid but not in graph, e.g.
-            # excluded or disconnected due to min weight
-            # NetworkXNoPath: no paths or the target type is
-            # not in the graph
-            pass
-
-    def all_shortest_paths(self, source, target):
-        """
-        Generator which yields all shortest paths between the source
-        and target types.
-
-        Parameters:
-        source   The source type.
-        target   The target type.
-
-        Yield: generator(steps)
-
-        steps Yield: tuple(source, target, rules)
-
-        source   The source type for this step of the information flow.
-        target   The target type for this step of the information flow.
-        rules    The list of rules creating this information flow step.
-        """
-        s = self.policy.lookup_type(source)
-        t = self.policy.lookup_type(target)
-
-        if self.rebuildsubgraph:
-            self._build_subgraph()
-
-        self.log.info("Generating all shortest information flow paths from {0} to {1}...".
-                      format(s, t))
-
-        try:
-            for path in nx.all_shortest_paths(self.subG, s, t):
-                yield self.__generate_steps(path)
-        except (NetworkXNoPath, NetworkXError, KeyError):
-            # NetworkXError: the type is valid but not in graph, e.g.
-            # excluded or disconnected due to min weight
-            # NetworkXNoPath: no paths or the target type is
-            # not in the graph
-            # KeyError: work around NetworkX bug
-            # when the source node is not in the graph
-            pass
-
-    def infoflows(self, type_, out=True):
-        """
-        Generator which yields all information flows in/out of a
-        specified source type.
-
-        Parameters:
-        source  The starting type.
-
-        Keyword Parameters:
-        out     If true, information flows out of the type will
-                be returned.  If false, information flows in to the
-                type will be returned.  Default is true.
-
-        Yield: generator(steps)
-
-        steps   A generator that returns the tuple of
-                source, target, and rules for each
-                information flow.
-        """
-        s = self.policy.lookup_type(type_)
-
-        if self.rebuildsubgraph:
-            self._build_subgraph()
-
-        self.log.info("Generating all information flows {0} {1}".
-                      format("out of" if out else "into", s))
-
-        if out:
-            flows = self.subG.out_edges_iter(s)
-        else:
-            flows = self.subG.in_edges_iter(s)
-
-        try:
-            for source, target in flows:
-                yield Edge(self.subG, source, target)
-        except NetworkXError:
-            # NetworkXError: the type is valid but not in graph, e.g.
-            # excluded or disconnected due to min weight
-            pass
-
-    def get_stats(self):  # pragma: no cover
-        """
-        Get the information flow graph statistics.
-
-        Return: str
-        """
-        if self.rebuildgraph:
-            self._build_graph()
-
-        return nx.info(self.G)
-
-    #
-    # Internal functions follow
-    #
-
-    def __generate_steps(self, path):
-        """
-        Generator which returns the source, target, and associated rules
-        for each information flow step.
-
-        Parameter:
-        path   A list of graph node names representing an information flow path.
-
-        Yield: tuple(source, target, rules)
-
-        source  The source type for this step of the information flow.
-        target  The target type for this step of the information flow.
-        rules   The list of rules creating this information flow step.
-        """
-        for s in range(1, len(path)):
-            yield Edge(self.subG, path[s - 1], path[s])
-
-    #
-    #
-    # Graph building functions
-    #
-    #
-    # 1. _build_graph determines the flow in each direction for each TE
-    #    rule and then expands the rule.  All information flows are
-    #    included in this main graph: memory is traded off for efficiency
-    #    as the main graph should only need to be rebuilt if permission
-    #    weights change.
-    # 2. _build_subgraph derives a subgraph which removes all excluded
-    #    types (nodes) and edges (information flows) which are below the
-    #    minimum weight. This subgraph is rebuilt only if the main graph
-    #    is rebuilt or the minimum weight or excluded types change.
-
-    def _build_graph(self):
-        self.G.clear()
-        self.G.name = "Information flow graph for {0}.".format(self.policy)
-
-        self.perm_map.map_policy(self.policy)
-
-        self.log.info("Building information flow graph from {0}...".format(self.policy))
-
-        for rule in self.policy.terules():
-            if rule.ruletype != TERuletype.allow:
-                continue
-
-            (rweight, wweight) = self.perm_map.rule_weight(rule)
-
-            for s, t in itertools.product(rule.source.expand(), rule.target.expand()):
-                # only add flows if they actually flow
-                # in or out of the source type type
-                if s != t:
-                    if wweight:
-                        edge = Edge(self.G, s, t, create=True)
-                        edge.rules.append(rule)
-                        edge.weight = wweight
-
-                    if rweight:
-                        edge = Edge(self.G, t, s, create=True)
-                        edge.rules.append(rule)
-                        edge.weight = rweight
-
-        self.rebuildgraph = False
-        self.rebuildsubgraph = True
-        self.log.info("Completed building information flow graph.")
-        self.log.debug("Graph stats: nodes: {0}, edges: {1}.".format(
-            nx.number_of_nodes(self.G),
-            nx.number_of_edges(self.G)))
-
-    def _build_subgraph(self):
-        if self.rebuildgraph:
-            self._build_graph()
-
-        self.log.info("Building information flow subgraph...")
-        self.log.debug("Excluding {0!r}".format(self.exclude))
-        self.log.debug("Min weight {0}".format(self.min_weight))
-
-        # delete excluded types from subgraph
-        nodes = [n for n in self.G.nodes() if n not in self.exclude]
-        self.subG = self.G.subgraph(nodes)
-
-        # delete edges below minimum weight.
-        # no need if weight is 1, since that
-        # does not exclude any edges.
-        if self.min_weight > 1:
-            delete_list = []
-            for s, t in self.subG.edges_iter():
-                edge = Edge(self.subG, s, t)
-                if edge.weight < self.min_weight:
-                    delete_list.append(edge)
-
-            self.subG.remove_edges_from(delete_list)
-
-        self.rebuildsubgraph = False
-        self.log.info("Completed building information flow subgraph.")
-        self.log.debug("Subgraph stats: nodes: {0}, edges: {1}.".format(
-            nx.number_of_nodes(self.subG),
-            nx.number_of_edges(self.subG)))
-
-
-class Edge(object):
-
-    """
-    A graph edge.  Also used for returning information flow steps.
-
-    Parameters:
-    graph       The NetworkX graph.
-    source      The source type of the edge.
-    target      The target type of the edge.
-
-    Keyword Parameters:
-    create      (T/F) create the edge if it does not exist.
-                The default is False.
-    """
-
-    rules = EdgeAttrList('rules')
-
-    # use capacity to store the info flow weight so
-    # we can use network flow algorithms naturally.
-    # The weight for each edge is 1 since each info
-    # flow step is no more costly than another
-    # (see below add_edge() call)
-    weight = EdgeAttrIntMax('capacity')
-
-    def __init__(self, graph, source, target, create=False):
-        self.G = graph
-        self.source = source
-        self.target = target
-
-        if not self.G.has_edge(source, target):
-            if create:
-                self.G.add_edge(source, target, weight=1)
-                self.rules = None
-                self.weight = None
-            else:
-                raise ValueError("Edge does not exist in graph")
-
-    def __getitem__(self, key):
-        # This is implemented so this object can be used in NetworkX
-        # functions that operate on (source, target) tuples
-        if isinstance(key, slice):
-            return [self._index_to_item(i) for i in range(* key.indices(2))]
-        else:
-            return self._index_to_item(key)
-
-    def _index_to_item(self, index):
-        """Return source or target based on index."""
-        if index == 0:
-            return self.source
-        elif index == 1:
-            return self.target
-        else:
-            raise IndexError("Invalid index (edges only have 2 items): {0}".format(index))
diff --git a/setools/permmap.py b/setools/permmap.py
deleted file mode 100644
index f8df82b..0000000
--- a/setools/permmap.py
+++ /dev/null
@@ -1,456 +0,0 @@
-# Copyright 2014-2015, Tresys Technology, LLC
-#
-# This file is part of SETools.
-#
-# SETools is free software: you can redistribute it and/or modify
-# it under the terms of the GNU Lesser General Public License as
-# published by the Free Software Foundation, either version 2.1 of
-# the License, or (at your option) any later version.
-#
-# SETools is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU Lesser General Public License for more details.
-#
-# You should have received a copy of the GNU Lesser General Public
-# License along with SETools.  If not, see
-# <http://www.gnu.org/licenses/>.
-#
-import sys
-import logging
-import copy
-from collections import OrderedDict
-from errno import ENOENT
-
-import pkg_resources
-
-from . import exception
-from . import policyrep
-from .descriptors import PermissionMapDescriptor
-from .policyrep import TERuletype
-
-infoflow_directions = ["r", "w", "b", "n", "u"]
-min_weight = 1
-max_weight = 10
-
-
-class PermissionMap(object):
-
-    """Permission Map for information flow analysis."""
-
-    def __init__(self, permmapfile=None):
-        """
-        Parameter:
-        permmapfile     The path to the permission map to load.
-        """
-        self.log = logging.getLogger(__name__)
-        self.permmap = OrderedDict()
-        self.permmapfile = None
-
-        if permmapfile:
-            self.load(permmapfile)
-        else:
-            distro = pkg_resources.get_distribution("setools")
-            # pylint: disable=no-member
-            path = "{0}/setools/perm_map".format(distro.location)
-            self.load(path)
-
-    def __str__(self):
-        return self.permmapfile
-
-    def __deepcopy__(self, memo):
-        newobj = PermissionMap.__new__(PermissionMap)
-        newobj.log = self.log
-        newobj.permmap = copy.deepcopy(self.permmap)
-        newobj.permmapfile = self.permmapfile
-        memo[id(self)] = newobj
-        return newobj
-
-    def __iter__(self):
-        for cls in self.classes():
-            for mapping in self.perms(cls):
-                yield mapping
-
-    def load(self, permmapfile):
-        """
-        Parameter:
-        permmapfile     The path to the permission map to load.
-        """
-        self.log.info("Opening permission map \"{0}\"".format(permmapfile))
-
-        # state machine
-        # 1 = read number of classes
-        # 2 = read class name and number of perms
-        # 3 = read perms
-        with open(permmapfile, "r") as mapfile:
-            total_perms = 0
-            class_count = 0
-            num_classes = 0
-            state = 1
-
-            self.permmap.clear()
-
-            for line_num, line in enumerate(mapfile, start=1):
-                entry = line.split()
-
-                if len(entry) == 0 or entry[0][0] == '#':
-                    continue
-
-                if state == 1:
-                    try:
-                        num_classes = int(entry[0])
-                    except ValueError:
-                        raise exception.PermissionMapParseError(
-                            "{0}:{1}:Invalid number of classes: {2}".
-                            format(permmapfile, line_num, entry[0]))
-
-                    if num_classes < 1:
-                        raise exception.PermissionMapParseError(
-                            "{0}:{1}:Number of classes must be positive: {2}".
-                            format(permmapfile, line_num, entry[0]))
-
-                    state = 2
-
-                elif state == 2:
-                    if len(entry) != 3 or entry[0] != "class":
-                        raise exception.PermissionMapParseError(
-                            "{0}:{1}:Invalid class declaration: {2}".
-                            format(permmapfile, line_num, entry))
-
-                    class_name = str(entry[1])
-
-                    try:
-                        num_perms = int(entry[2])
-                    except ValueError:
-                        raise exception.PermissionMapParseError(
-                            "{0}:{1}:Invalid number of permissions: {2}".
-                            format(permmapfile, line_num, entry[2]))
-
-                    if num_perms < 1:
-                        raise exception.PermissionMapParseError(
-                            "{0}:{1}:Number of permissions must be positive: {2}".
-                            format(permmapfile, line_num, entry[2]))
-
-                    class_count += 1
-                    if class_count > num_classes:
-                        raise exception.PermissionMapParseError(
-                            "{0}:{1}:Extra class found: {2}".
-                            format(permmapfile, line_num, class_name))
-
-                    self.permmap[class_name] = OrderedDict()
-                    perm_count = 0
-                    state = 3
-
-                elif state == 3:
-                    perm_name = str(entry[0])
-
-                    flow_direction = str(entry[1])
-                    if flow_direction not in infoflow_directions:
-                        raise exception.PermissionMapParseError(
-                            "{0}:{1}:Invalid information flow direction: {2}".
-                            format(permmapfile, line_num, entry[1]))
-
-                    try:
-                        weight = int(entry[2])
-                    except ValueError:
-                        raise exception.PermissionMapParseError(
-                            "{0}:{1}:Invalid permission weight: {2}".
-                            format(permmapfile, line_num, entry[2]))
-
-                    if not min_weight <= weight <= max_weight:
-                        raise exception.PermissionMapParseError(
-                            "{0}:{1}:Permission weight must be {3}-{4}: {2}".
-                            format(permmapfile, line_num, entry[2],
-                                   min_weight, max_weight))
-
-                    self.log.debug("Read {0}:{1} {2} {3}".format(
-                                   class_name, perm_name, flow_direction, weight))
-
-                    if flow_direction == 'u':
-                        self.log.info("Permission {0}:{1} is unmapped.".format(
-                                      class_name, perm_name))
-
-                    mapping = Mapping(self.permmap, class_name, perm_name, create=True)
-                    mapping.direction = flow_direction
-                    mapping.weight = weight
-
-                    total_perms += 1
-                    perm_count += 1
-                    if perm_count >= num_perms:
-                        state = 2
-
-        self.permmapfile = permmapfile
-        self.log.info("Successfully opened permission map \"{0}\"".format(permmapfile))
-        self.log.debug("Read {0} classes and {1} total permissions.".format(
-                       class_count, total_perms))
-
-    def save(self, permmapfile):
-        """
-        Save the permission map to the specified path.  Existing files
-        will be overwritten.
-
-        Parameter:
-        permmapfile         The path to write the permission map.
-        """
-        with open(permmapfile, "w") as mapfile:
-            self.log.info("Writing permission map to \"{0}\"".format(permmapfile))
-            mapfile.write("{0}\n\n".format(len(self.permmap)))
-
-            for classname, perms in self.permmap.items():
-                mapfile.write("class {0} {1}\n".format(classname, len(perms)))
-
-                for permname, settings in perms.items():
-                    direction = settings['direction']
-                    weight = settings['weight']
-
-                    assert min_weight <= weight <= max_weight, \
-                        "{0}:{1} weight is out of range ({2}). This is an SETools bug.".format(
-                            classname, permname, weight)
-
-                    assert direction in infoflow_directions, \
-                        "{0}:{1} flow direction ({2}) is invalid. This is an SETools bug.".format(
-                            classname, permname, direction)
-
-                    if direction == 'u':
-                        self.log.warning("Warning: permission {0} in class {1} is unmapped.".format(
-                                         permname, classname))
-
-                    mapfile.write("{0:>20} {1:>9} {2:>9}\n".format(permname, direction, weight))
-
-                mapfile.write("\n")
-
-            self.log.info("Successfully wrote permission map to \"{0}\"".format(permmapfile))
-
-    def classes(self):
-        """
-        Generate class names in the permission map.
-
-        Yield:
-        class       An object class name.
-        """
-        for cls in self.permmap.keys():
-            yield cls
-
-    def perms(self, class_):
-        """
-        Generate permission mappings for the specified class.
-
-        Parameter:
-        class_      An object class name.
-
-        Yield:
-        Mapping     A permission's complete map (weight, direction, enabled)
-        """
-        try:
-            for perm in self.permmap[class_].keys():
-                yield Mapping(self.permmap, class_, perm)
-        except KeyError:
-            raise exception.UnmappedClass("{0} is not mapped.".format(class_))
-
-    def mapping(self, class_, perm):
-        """Retrieve a specific permission's mapping."""
-        return Mapping(self.permmap, class_, perm)
-
-    def exclude_class(self, class_):
-        """
-        Exclude all permissions in an object class for calculating rule weights.
-
-        Parameter:
-        class_              The object class to exclude.
-
-        Exceptions:
-        UnmappedClass       The specified object class is not mapped.
-        """
-        for perm in self.perms(class_):
-            perm.enabled = False
-
-    def exclude_permission(self, class_, permission):
-        """
-        Exclude a permission for calculating rule weights.
-
-        Parameter:
-        class_              The object class of the permission.
-        permission          The permission name to exclude.
-
-        Exceptions:
-        UnmappedClass       The specified object class is not mapped.
-        UnmappedPermission  The specified permission is not mapped for the object class.
-        """
-        Mapping(self.permmap, class_, permission).enabled = False
-
-    def include_class(self, class_):
-        """
-        Include all permissions in an object class for calculating rule weights.
-
-        Parameter:
-        class_              The object class to include.
-
-        Exceptions:
-        UnmappedClass       The specified object class is not mapped.
-        """
-
-        for perm in self.perms(class_):
-            perm.enabled = True
-
-    def include_permission(self, class_, permission):
-        """
-        Include a permission for calculating rule weights.
-
-        Parameter:
-        class_              The object class of the permission.
-        permission          The permission name to include.
-
-        Exceptions:
-        UnmappedClass       The specified object class is not mapped.
-        UnmappedPermission  The specified permission is not mapped for the object class.
-        """
-
-        Mapping(self.permmap, class_, permission).enabled = True
-
-    def map_policy(self, policy):
-        """Create mappings for all classes and permissions in the specified policy."""
-        for class_ in policy.classes():
-            class_name = str(class_)
-
-            if class_name not in self.permmap:
-                self.log.debug("Adding unmapped class {0} from {1}".format(class_name, policy))
-                self.permmap[class_name] = OrderedDict()
-
-            perms = class_.perms
-
-            try:
-                perms |= class_.common.perms
-            except policyrep.exception.NoCommon:
-                pass
-
-            for perm_name in perms:
-                if perm_name not in self.permmap[class_name]:
-                    self.log.debug("Adding unmapped permission {0} in {1} from {2}".
-                                   format(perm_name, class_name, policy))
-                    Mapping(self.permmap, class_name, perm_name, create=True)
-
-    def rule_weight(self, rule):
-        """
-        Get the type enforcement rule's information flow read and write weights.
-
-        Parameter:
-        rule            A type enforcement rule.
-
-        Return: Tuple(read_weight, write_weight)
-        read_weight     The type enforcement rule's read weight.
-        write_weight    The type enforcement rule's write weight.
-        """
-
-        write_weight = 0
-        read_weight = 0
-        class_name = str(rule.tclass)
-
-        if rule.ruletype != TERuletype.allow:
-            raise exception.RuleTypeError("{0} rules cannot be used for calculating a weight".
-                                          format(rule.ruletype))
-
-        # iterate over the permissions and determine the
-        # weight of the rule in each direction. The result
-        # is the largest-weight permission in each direction
-        for perm_name in rule.perms:
-            mapping = Mapping(self.permmap, class_name, perm_name)
-
-            if not mapping.enabled:
-                continue
-
-            if mapping.direction == "r":
-                read_weight = max(read_weight, mapping.weight)
-            elif mapping.direction == "w":
-                write_weight = max(write_weight, mapping.weight)
-            elif mapping.direction == "b":
-                read_weight = max(read_weight, mapping.weight)
-                write_weight = max(write_weight, mapping.weight)
-
-        return (read_weight, write_weight)
-
-    def set_direction(self, class_, permission, direction):
-        """
-        Set the information flow direction of a permission.
-
-        Parameter:
-        class_              The object class of the permission.
-        permission          The permission name.
-        direction           The information flow direction the permission (r/w/b/n).
-
-        Exceptions:
-        UnmappedClass       The specified object class is not mapped.
-        UnmappedPermission  The specified permission is not mapped for the object class.
-        """
-        Mapping(self.permmap, class_, permission).direction = direction
-
-    def set_weight(self, class_, permission, weight):
-        """
-        Set the weight of a permission.
-
-        Parameter:
-        class_              The object class of the permission.
-        permission          The permission name.
-        weight              The weight of the permission (1-10).
-
-        Exceptions:
-        UnmappedClass       The specified object class is not mapped.
-        UnmappedPermission  The specified permission is not mapped for the object class.
-        """
-        Mapping(self.permmap, class_, permission).weight = weight
-
-
-#
-# Settings Validation Functions
-#
-def validate_weight(weight):
-    if not min_weight <= weight <= max_weight:
-        raise ValueError("Permission weights must be 1-10: {0}".format(weight))
-
-    return weight
-
-
-def validate_direction(direction):
-    if direction not in infoflow_directions:
-        raise ValueError("Invalid information flow direction: {0}".format(direction))
-
-    return direction
-
-
-def validate_enabled(enabled):
-    return bool(enabled)
-
-
-class Mapping(object):
-
-    """A mapping for a permission in the permission map."""
-
-    weight = PermissionMapDescriptor("weight", validate_weight)
-    direction = PermissionMapDescriptor("direction", validate_direction)
-    enabled = PermissionMapDescriptor("enabled", validate_enabled)
-
-    def __init__(self, perm_map, classname, permission, create=False):
-        self.perm_map = perm_map
-        self.class_ = classname
-        self.perm = permission
-
-        if create:
-            if classname not in self.perm_map:
-                self.perm_map[classname] = OrderedDict()
-
-            self.perm_map[classname][permission] = {'direction': 'u',
-                                                    'weight': 1,
-                                                    'enabled': True}
-
-        else:
-            if classname not in self.perm_map:
-                raise exception.UnmappedClass("{0} is not mapped.".format(classname))
-
-            if permission not in self.perm_map[classname]:
-                raise exception.UnmappedPermission("{0}:{1} is not mapped.".
-                                                   format(classname, permission))
-
-    def __lt__(self, other):
-        if self.class_ == other.class_:
-            return self.perm < other.perm
-        else:
-            return self.class_ < other.class_
